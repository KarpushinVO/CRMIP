import math


from openpyxl import load_workbook
from tabulate import tabulate
import scipy

#Внешняя функция:
def differ(list1, list2):
    MSE = [(i + j) ** 2 for i, j in zip(list1, list2)]
    return sum(MSE)/len(MSE)

class ProxyModel:
    def __init__(self, excel):
        self.sheet = excel.worksheets[0] # Атрибут для книги эксель
        self.inj_amount = 0 # Количество нагнетательных скважин
        self.prod_amount = 0 # Количество добывающих скважин
        self.f = {} # Коэффициент взаимовлияния
        self.tau = {} # Коэффициент временного лага
        self.qliq0 = {} # Начальные дебиты
        self.inj_wells_rates = {} # Словарь ключи имена скважин, значения данные по закачке # TODO: Можно оставить как локальну переменную в методе
        self.prod_wells_rates = {} # Данные по добыче # TODO: Можно оставить как локальну переменную в методе
        self.prod_CRM = {} # Об
        self.MSE = {}
        self.sum_prod_CRM = {} # Сумма всех CRM моделей (равна количеству добывающих скважин)
        self.time = [] # Время, в целом оно не нужно - есть количество строк, то есть шагов "К"


    def amount_of_params(self): # TODO: Мне кажется всю эту функцию можно оставить в init
        for i in range(2, self.sheet.max_row):
            self.time.append(self.sheet[i][0].value)

        for column in range(1, self.sheet.max_column):
            q_data = [] #временная переменная для добавления расходов доб/нагн скважин
            # Идем по листу и добавляем информацию в словари
            if 'INJ' in self.sheet[1][column].value:
                self.inj_amount += 1
                for i in range(2, self.sheet.max_row):
                    q_data.append(self.sheet[i][column].value)
                self.inj_wells_rates.update({self.sheet[1][column].value: q_data})
            else:
                self.prod_amount += 1
                for i in range(2, self.sheet.max_row):
                    q_data.append(self.sheet[i][column].value)
                self.prod_wells_rates.update({self.sheet[1][column].value: q_data})
                self.MSE.update({'MSE ' + self.sheet[1][column].value: None})

        # Создаем словари с нужными параметрами и названиями CRM-скважин-моделей
        for i in self.prod_wells_rates:
            for j in self.inj_wells_rates:
                self.f.update({'f_' + str(i[5::]) +  ' ' + str(j[4::]): None})
                self.tau.update({'tau_' + str(i[5::]) + ' ' + str(j[4::]): None})
                self.qliq0.update({'qliq0_' + str(i[5::]) +  ' ' + str(j[4::]): None})
                self.prod_CRM.update({i[5::] + ' & ' + j[4::]: []})
        return self.prod_CRM

    def make_initial_conditions(self):
        #Задаем начальные значения для f
        for i in self.f:
            self.f[i] = round(1/self.inj_amount, 2)

        #Задаем начальные значения для tau
        for i in self.tau:
            self.tau[i] = 100

        #Задаем начельные условия для qliq0
        automatic_initial_qliq0 = list(self.qliq0.keys())
        step = len(automatic_initial_qliq0) // self.prod_amount
        q_0 = [] # Временная переменная, чтобы передать первые значения из дебитов скважин и распределить их потом по стартовым дебитам CRM скважин
        for i in self.prod_wells_rates:
            q_0.append(self.prod_wells_rates[i][0] // step)

        boundary2 = step
        boundary1 = 0
        for i in range(0, len(q_0)):
            for j in range(boundary1, boundary2):
                automatic_initial_qliq0[j] = q_0[i]
            boundary2 += step
            boundary1 += step
        self.qliq0 = {i: j for i, j in zip(list(self.qliq0.keys()), automatic_initial_qliq0)}
        return self.qliq0

    def crm_calculate(self, in_package): #TODO: Нужно донастроить функциюю по аргументам, в циклах используются атрибуты класса, а нужно аргументы прим.: тау f
        #Добавляем данные в списки словаря из списка q аргумента функции
        list_length = len(self.qliq0) #временная переменная для создания списка параметров на вход

        q_input = in_package[0:list_length]
        tau_input = in_package[list_length: list_length*2]
        f_input = in_package[list_length*2: list_length*3]


        for i, j in enumerate(self.prod_CRM): # TODO: обернуть в функцию, чтобы было красиво
            self.prod_CRM[j].append(q_input[i])

        for i, j in enumerate(self.tau):
            #Значение по ключу j равно знчение из тау инпут
            self.tau[j] = tau_input[i]
        for i, j in enumerate(self.f):
            self.f[j] = f_input[i]

        for well_i, tau_i, f_i in zip(self.prod_CRM, self.tau, self.f):
            for i in range(1, len(self.time)): # TODO: проверить по последнему значению входит ли?!
                self.prod_CRM[well_i].append(round(self.prod_CRM[well_i][i-1] * math.exp(-(i - (i-1))/self.tau[tau_i]) + (1 - math.exp(-(i - (i-1))/self.tau[tau_i])) * self.f[f_i], 1))

        self.sum_prod_CRM = self.sum_prod_CRM.fromkeys(list(self.prod_wells_rates.keys()), []) # Зачем-то копирует словарь уже другой

        step = len(list(self.prod_CRM.values())) // self.prod_amount
        boundary2 = step
        boundary1 = 0

        for i in self.sum_prod_CRM:
            self.sum_prod_CRM[i] = list(map(sum, zip(*list(self.prod_CRM.values())[boundary1:boundary2])))
            boundary2 += step
            boundary1 += step

        # Подсчет невязки
        for i, j, k in zip(self.MSE, self.sum_prod_CRM, self.prod_wells_rates):
            self.MSE[i] = round(differ(self.sum_prod_CRM[j], self.prod_wells_rates[k]), 3)
        return sum(self.MSE.values())



if __name__ == "__main__":
    wb = load_workbook(r"technical_data2.xlsx")
    model1 = ProxyModel(wb)
    model1.amount_of_params()

    print(model1.amount_of_params())
    print(model1.prod_wells_rates)

#result = scipy.optimize.minimize(model1.crm_calculate, [266, 266, 788, 788, 14, 14, 14, 14, 0.1, 0.1, 0.1, 0.1])
